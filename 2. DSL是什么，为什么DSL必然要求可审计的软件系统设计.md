1. 什么是DSL（此章为总章子章节2. 新流程（结构驱动型自动流水线）详细解释）

DSL（领域特定语言，Domain-Specific Language） 是一种针对特定领域或任务设计的编程语言。与通用编程语言（如JavaScript、Python等）相比，DSL专注于简化特定领域的表达，能够更加直观和高效地解决业务中的特定问题。

在前端开发中，DSL的应用可以涵盖以下几个方面：

UI描述：通过DSL来定义页面布局、组件配置、交互行为等；

业务规则：DSL可以描述复杂的业务流程和规则逻辑；

数据交互：定义前后端的数据交换格式和操作接口。

1.1 DSL的实际案例：用户列表页面配置

以下是一个用于用户列表页面的DSL配置示例，展示了如何通过DSL语言来描述页面布局、组件、数据源、权限等内容：
```yaml
page: UserList
layout: TablePage
permissions:
  view: admin, user
components:
  - type: SearchBar
    fields: [username, role, status]
  - type: Table
    datasource: /api/users
    columns:
      - field: username
        label: 用户名
      - field: role
        enum: [admin, user]
      - field: status
        enum: [active, banned]
    actions:
      - label: 编辑
        modal: EditUser
      - label: 禁用
        api: POST /api/user/ban
modals:
  - name: EditUser
    fields:
      - field: username
        type: text
      - field: role
        type: select
        options: [admin, user]
      - field: status
        type: select
        options: [active, banned]
apis:
  - endpoint: /api/users
    method: GET
    parameters:
      - name: username
        type: string
        required: false
      - name: role
        type: string
        required: false
      - name: status
        type: string
        required: false
    description: 获取用户列表
  - endpoint: /api/user/ban
    method: POST
    description: 禁用用户
```
在这个DSL示例中，我们看到：

页面配置：描述了页面名称 UserList 和页面布局 TablePage；

权限控制：列出了该页面的查看权限，只有admin和user角色可以访问；

组件配置：定义了页面上使用的组件（如SearchBar和Table），每个组件的配置项包括字段、数据源、列定义、操作项等。

1.2 DSL语言的优势

通过DSL，我们可以简洁、直观地描述前端页面的构成、交互行为以及权限控制等，这些内容通常需要开发者在代码中逐步实现，而DSL可以通过声明性语言快速定义，从而提高开发效率，降低出错概率。

2. 为什么DSL必然要求可审计的软件系统设计

DSL的核心价值在于简化复杂的业务逻辑，使得开发人员可以更加专注于业务设计而非底层实现。然而，DSL带来的抽象性和简化也可能带来隐性风险，如果不加以管理，可能导致代码不可追溯、不可验证。因此，DSL必须与可审计的软件系统设计结合，才能保证系统的健壮性、可维护性和可扩展性。

2.1 复杂业务的抽象性与可审计性要求

DSL的设计往往针对复杂的业务逻辑进行抽象，简化了开发过程，但这种简化也可能带来潜在的不可见问题。例如，在上述用户列表页面的DSL配置中，业务规则和数据源都通过DSL进行了声明。若DSL配置随时间发生变化，必须确保这些变更能够被审计和追踪，以防止由于修改不当而引入的问题。

为此，可审计性是DSL必须具备的重要特性，它能帮助我们：

集中化裁决逻辑：所有业务规则和状态迁移都应集中在裁决层，避免分散到多个地方，减少耦合度；

版本管理：DSL的变更必须可以追溯，确保系统升级时不丢失原有逻辑；

日志与监控：对DSL配置的每次修改都应记录日志，便于后续审计和追溯。

2.2 审计机制的实现

DSL的实现必须支持如下审计机制：

裁决层集中管理：将业务逻辑集中在裁决层，避免在前端各个组件中进行散乱的规则判断。

版本化与历史追溯：DSL的规则和配置应该支持版本控制，开发人员可以回溯历史配置，确保每次变更都是可控的。

单元测试支持：DSL的实现应具有较好的单元测试支持，开发人员可以独立地测试每个DSL配置项的正确性。

3. 从传统Vue的单元测试到完整6步法（可审计的软件系统测试）
3.1 传统Vue的单元测试实践

在传统的Vue项目中，前端单元测试通常依赖于vue-test-utils库，通过mock和stubs来测试组件行为。最基本的单元测试会验证组件是否按预期渲染，是否响应用户交互等。

示例1：Vue组件单元测试

假设我们有一个简单的Counter组件，它的功能是增加计数值：
```vue
<template>
  <button @click="increment">{{ count }}</button>
</template>

<script>
export default {
  data() {
    return { count: 0 };
  },
  methods: {
    increment() {
      this.count += 1;
    }
  }
}
</script>
```
```js
// 单元测试
import { mount } from '@vue/test-utils'
import Counter from '@/components/Counter.vue'

describe('Counter.vue', () => {
  it('increments the counter when clicked', async () => {
    const wrapper = mount(Counter)
    await wrapper.find('button').trigger('click')
    expect(wrapper.text()).toBe('1')
  })
})

```

在传统的单元测试中，测试关注的是组件的渲染和行为，而业务逻辑和状态迁移往往是隐式地存在于组件内部。

3.2 过渡到6步法

6步法的核心是将复杂的业务逻辑抽象为一个集中裁决层，而不再将状态迁移和业务规则分散到组件内。通过逐步引入集中的裁决逻辑，我们将业务规则从组件内部抽象出来，最终实现可审计、可测试的业务系统。
我们以无人机巡航任务为例，展示如何从传统Vue单元测试过渡到6步法。


步骤1：业务最小定义

巡航区域（Zone）：
```ts
type ZoneType =
  | 'industrial'   // 工业区
  | 'mining'       // 矿区
  | 'it_park'      // IT 产业园
  | 'farmland'     // 农田 / 农场
```
巡航任务（Mission）
```ts
type MissionType =
  | 'patrol'       // 常规巡航
  | 'inspection'   // 设备巡检
  | 'mapping'      // 测绘
  | 'emergency'    // 紧急处置
```
约束现实假设（非常关键）

不是所有区域允许所有任务

不是所有阶段允许所有操作

出错 = 事故（所以 if 失败成本极高）

反例：if 驱动（你已经知道会炸）
```ts
if (zone === 'industrial') {
  if (mission === 'emergency') {
    if (altitude < 120) {
      // ...
    }
  }
}
```


步骤2：状态替代条件

明确定义“阶段”，而不是条件

```ts
type DroneState =
  | 'idle'
  | 'takeoff'
  | 'cruising'
  | 'monitoring'
  | 'returning'
  | 'emergency'

```
注意：
状态是“世界事实”，不是判断结果


步骤3：状态迁移规则集中管理

通过集中管理状态迁移，我们确保状态的变化逻辑不被分散在多个地方：
```ts
const transitions: Record<DroneState, DroneState[]> = {
  idle: ['takeoff'],
  takeoff: ['cruising', 'emergency'],
  cruising: ['monitoring', 'returning', 'emergency'],
  monitoring: ['returning', 'emergency'],
  returning: ['idle'],
  emergency: ['returning']
}

```

步骤4：能力模型

区域 → 能力模型（Capability）
1️⃣ 区域不直接参与判断，只赋予能力
```ts
type Capability =
  | 'lowAltitude'
  | 'thermalScan'
  | 'nightFlight'
  | 'longHover'
```
```ts
const zoneCapabilities: Record<ZoneType, Capability[]> = {
  industrial: ['thermalScan', 'nightFlight'],
  mining: ['thermalScan', 'longHover'],
  it_park: ['nightFlight'],
  farmland: ['lowAltitude', 'longHover']
}
```
关键变化：

区域 ≠ if

区域 = 能力集合

2️⃣ 任务声明“需要什么能力”
```ts
const missionRequirements: Record<MissionType, Capability[]> = {
  patrol: [],
  inspection: ['thermalScan'],
  mapping: ['lowAltitude'],
  emergency: ['nightFlight']
}
```
3️⃣ 框架级判定（集中一次）

步骤五：业务裁决层（Domain / Policy / Ability Resolver）
```ts
function canRunMission(
  zone: ZoneType,
  mission: MissionType
): boolean {
  const caps = zoneCapabilities[zone]
  const needs = missionRequirements[mission]

  return needs.every(n => caps.includes(n))
}

```
步骤6：组件按能力对象展示
组件输入的不是“条件”，而是“已决策结果”。组件只负责渲染和消费能力对象。这样就避免了组件内部拼接业务规则，确保了系统的可审计性和可维护性。
```ts
type MissionContext =
  | { kind: 'allowed'; mission: MissionType }
  | { kind: 'forbidden'; reason: string }
```
```ts
function resolveMission(zone: ZoneType, mission: MissionType): MissionContext {
  if (!canRunMission(zone, mission)) {
    return { kind: 'forbidden', reason: 'capability mismatch' }
  }
  return { kind: 'allowed', mission }
}
```
Vue 组件
```vue
<template>
  <MissionPanel v-if="ctx.kind === 'allowed'" />
  <ErrorPanel v-else />
</template>

<script setup lang="ts">
defineProps<{ ctx: MissionContext }>()
</script>
```
这里的 v-if 是 UI 分支，
不再是业务判断。
---
3.3.1 6步法的好处:测试形态已经完全改变
1️⃣ 不测组件条件

不再写：
```ts
expect(button.exists()).toBe(true)
```
2️⃣ 测“系统事实”
```ts
test('farmland cannot run emergency mission', () => {
  const ctx = resolveMission('farmland', 'emergency')
  expect(ctx.kind).toBe('forbidden')
})
```ts
test('industrial allows emergency mission', () => {
  const ctx = resolveMission('industrial', 'emergency')
  expect(ctx.kind).toBe('allowed')
})
```
这是业务级、可穷举、可审计的测试。

3.4 泼冷水：为什么完整6步法在实际项目中难以实现

6步法虽然提供了完整的业务抽象和系统化的裁决逻辑，但它的条件比较苛刻，需要团队在多个方面达成一致：

- 裁决层集中管理：所有业务规则必须集中在一个地方，不可分散。

- 能力对象消费：组件只关心能力对象，而不关心业务规则的具体实现。

- 版本化与历史追溯：业务规则的版本控制必须做到位。

而江苏绝大多数项目（不点名）的真实特征是：

- 生命周期不稳定

- 需求来源多头

- 政策 / 领导意志强干预

- 技术债务长期不可清

- “交付优先于正确性”

👉 在这种环境下，完整 6 步是反现实的。

3.4.1 逐条说清楚：哪些步在现实中会“直接失败”
①业务最小定义 ❌（高概率失败）

原因不是技术，而是：

业务定义权不在研发

需求是“口头 + 文档 + 会上临时加”

边界不断漂移

结果：

最小定义还没固化，系统已经上线三次了。

② 状态替代条件 ❌（大规模失败）

原因：

UI 与业务强耦合

页面驱动逻辑

状态来自接口拼接

现实写法仍然是：
```ts
v-if="status === 3 && type !== 2 && flag"
```
因为没有稳定的“状态语义来源”。

③ 状态迁移规则集中管理 ❌❌（几乎不可能）

这是最理想化的一步。

现实中：

状态迁移被分散在:

- 接口回调

- watch

- 生命周期

- 用户操作

没有单一决策点

状态不是“迁移”的，是“被撞出来的”。

④ 业务能力模型 ⚠️（小范围可行）

这一点反而是现实中最有可能落地的，但会被严重降级：

不是 capability

而是 permission / feature flag / role
```ts
canEdit
canDelete
showExport
```
👉 “能力”会被压缩成 boolean 集合

⑤ 框架级业务流程判断 ❌（现实几乎不存在）

这一步需要：

- TS

- 架构话语权

- 长期维护承诺

在多数项目里：

连统一 loading 管理都做不到
更别说统一业务流程裁决了

⑥ 组件按流程结果展示 ✅（唯一稳定可行）

这一条反而是最容易做到的：

UI 吃结果

少做判断

少担责任

所以你会看到大量项目其实已经是：
```vue
<Component v-if="xxx" />
```
只是 xxx 的来源极其混乱。

3.5 6步法的条件苛刻性与过渡到2.5步法
由于实际项目中很难一次性做到完美的6步法，我们提出了2.5步法，它是一个更为渐进的实践路径：

2.5步法：在实际项目中，我们可以通过逐步实现6步法的核心概念来达到目标。
2.5步法的核心是：

- 组件只消费能力对象，不关心业务规则的实现。

- 状态迁移和业务规则集中到裁决层进行管理。

- 通过逐步引入裁决层和能力模型来简化系统。

3.5.1 2.5步法的实施策略

✅ Step A：业务条件命名化（不是状态机）

不搞状态机，不搞迁移图，只做一件事：
```ts
// ❌
if (a === 3 && b !== 2)

// ✅
if (canSubmitForm(data))
```
命名，是最低成本、最高收益的结构化。

✅ Step B：条件集中，但不统一裁决

允许多个“判断源”，但：

禁止在模板里写复杂判断

禁止在组件里拼业务规则,应该：
```ts
useOrderPermission()
useDronePermission()
```
组件“不拼规则”的核心设计：能力注入，而非条件下发
❌ 错误的“条件下发”
```ts
props: {
  userRole,
  orderStatus,
  canRefundFlag
}
```
组件必然拼规则，因为它拿到的是原始材料
✅ 正确的“能力注入”
```ts
props: {
  orderAbility: OrderAbility
}
```
组件内部最多：
```ts
if (orderAbility.canRefund)
```
这是 状态读取，不是 业务裁决

⚠️ Step C（半步）：关键路径抽象

只对高风险 / 高频返工的流程：

审批

权限

状态流转

做有限状态建模。

不是全项目，只是：

“这条线不能再出事故了”。

3.6 总结：
如果一个环境里：

上限6步法实践可验证的软件系统做不到（可以理解）

连2.5步生存线都无法建立

那么系统就会退化为：

“靠人兜底的经验系统”，也无法很好的支持DSL的可审计需求。更无法再将来将软件开发过渡到人机协作模式。

4. 对比意图控制层和传统MVVM的差异
4.1 传统MVVM的局限性

4.1.1 在传统的MVVM模式中，ViewModel往往承担了业务逻辑和状态管理的重任。随着应用复杂度增加，ViewModel会变得越来越庞大，包含大量的业务规则。
举例：
```ts
class UserViewModel {
  canEdit = false

  updateFromServer(data: UserData) {
    // ❌ 在 viewmodel 层独立判断业务
    this.canEdit = data.role === 'admin' && data.status === 'active'
  }
}
```
这种模式存在的问题是：

规则散乱：业务逻辑和视图逻辑混杂，导致组件难以维护。

难以扩展：每当业务规则发生变化时，必须在多个地方进行修改。

不可测试：由于规则分散，难以单独测试业务逻辑。

控制逻辑难以追踪：业务规则的变更难以审计和追溯。不能很好的支持DSL的可审计需求。

4.1.2 改成“裁决层统一处理”
数据流：
```rust
落库数据 -> HTTP 拉取 -> 业务裁决层 -> 能力对象 -> UI/组件消费

```
```ts
// 用户数据接口
interface UserData {
  role: string
  status: 'active' | 'inactive'
  currentStep: number
}

// 裁决层
function resolveUserAbility(user: UserData) {
  return {
    canEdit: user.role === 'admin' && user.status === 'active',
    canApprove: user.currentStep === 2 && user.role === 'manager',
    canDelete: user.role === 'superadmin',
  }
}

// 客户端 ViewModel / 组件只消费能力
const userAbility = resolveUserAbility(fetchedUserData)
if (userAbility.canEdit) { /* render edit UI */ }

```
4.1.3 MVVM VS 业务裁决层模式
| 维度        | 传统 MVVM          | 业务裁决层模式       |
| --------- | ---------------- | ------------- |
| 规则位置      | 各 ViewModel / 组件 | 裁决层集中         |
| 可测试性      | 弱，依赖组件 / 状态      | 强，可单测函数       |
| 版本迭代      | 散落修改             | 单点修改          |
| CS 架构可扩展性 | 客户端各自维护状态        | 所有客户端共享裁决 API |
| 组件职责      | 拼条件 + 渲染         | 只消费能力         |
4.1.4 业务裁决层模式 VS IOC

IOC 核心：依赖反转，把“控制权”从使用者转给容器 / 上层

业务裁决层类比 IOC：

组件不决定业务规则如何执行

裁决层（集中逻辑）决定能力结果

组件依赖于裁决层的能力输出（接口注入）
```rust
[API/DB] -> [裁决层/Ability Resolver] -> [能力对象] -> [组件/VM]
                                  ↑
                         [版本/规则迭代管理]
```

4.2 意图控制层的优势

在意图控制层模型中，所有的业务规则和状态迁移都集中在裁决层中，组件仅消费能力对象。这样可以实现：

业务规则集中管理，便于修改和扩展。

组件职责单一，仅负责呈现和处理能力对象，不涉及业务逻辑。

可审计性和可测试性，每个业务规则都可以单独测试，系统变化可以追溯。
最终 让 DSL 能够在一个可审计的软件系统中高效运行。